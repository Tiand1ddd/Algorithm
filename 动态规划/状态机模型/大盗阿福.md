---
title: 大盗阿福
categories:  
  - 动态规划
  - 状态机模型
date: 2024-7-27
tags:
  - dp
  - 状态机
comments: true
---

阿福是一名经验丰富的大盗。趁着月黑风高，阿福打算今晚洗劫一条街上的店铺。

这条街上一共有 N家店铺，每家店中都有一些现金。

阿福事先调查得知，只有当他同时洗劫了两家相邻的店铺时，街上的报警系统才会启动，然后警察就会蜂拥而至。

作为一向谨慎作案的大盗，阿福不愿意冒着被警察追捕的风险行窃。

他想知道，在不惊动警察的情况下，他今晚最多可以得到多少现金？

#### 输入格式

输入的第一行是一个整数 𝑇，表示一共有 T组数据。

接下来的每组数据，第一行是一个整数 N，表示一共有 N 家店铺。

第二行是 N 个被空格分开的正整数，表示每一家店铺中的现金数量。

每家店铺中的现金数量均不超过1000。

#### 输出格式

对于每组数据，输出一行。

该行包含一个整数，表示阿福在不惊动警察的情况下可以得到的现金数量。

#### 数据范围
1≤T≤50   

1≤N≤100000

#### 输入样例：

```
2
3
1 8 2
4
10 7 6 14
```

#### 输出样例：

```
8
24
```

#### 样例解释

对于第一组样例，阿福选择第2家店铺行窃，获得的现金数量为8。

对于第二组样例，阿福选择第1和4家店铺行窃，获得的现金数量为10+14=24。    

##### 前置知识

状态机（State Machine），又称有限状态自动机（Finite State Machine, FSM），是一种用于描述系统行为或功能行为的数学模型。它通常包含一组状态、一组转换条件以及动作执行，通过在不同状态之间进行转换来模拟系统的行为。   

以上就是关于状态机的概念，通俗的解释就是状态之间的转移，以及转移所带来的效果。举个简单的例子，请看下图:

![状态转移样例](https://cdn.jsdelivr.net/gh/Tiand1ddd/tuchuang@main/img/202407310023954.jpg)

根据上图，我们可以知道当n为正整数的时候，该状态转移可以称为简单的状态转移模型。

#### 解题思路

对于这道题，首先，我们考虑朴素做法，因为N的最大值为1e6，$n^2$的时间复杂度会超时，所以不可取，但是我们可以大概知道这道题正确解法的时间复杂度一定是O($n$)或者是O($nlogn$)的。   

这里我们需要根据前置知识引入一个新的dp模型--状态机模型。对于这道题，我们要将状态抽象出来，可以简单的通过定义0和1来表示当前的店铺有没有被抢劫。状态转移图如下所示:    

![状态转移图](https://cdn.jsdelivr.net/gh/Tiand1ddd/tuchuang@main/img/202408042226188.jpg)

<span style ="color:red;">状态表示</span>:`f[i][j]`:表示所有走了i步，且当前状态为j的所有走法，j的值只能为0或1   `f[i][j]`的值表示最大收益即max

<span style = "color:red;">状态计算</span>:根据上面的状态转移图我们可以知道`f[i][1]`只能由`f[i-1][0]`转移而来，所以有`f[i-1][1]=f[i-1][0]+w[i]`，`f[i][0]`可由状态0和1转移而来，所以`f[i][0] = max(f[i-1][0]+w[i],f[i-1][1])`

综上述，我们将最后的结果娶一个max即可，因为不知道最大收益的走法对于最后一个店铺是否抢劫，所以我们需要取一个max，即`max(f[n][0],f[n][1])`。代码如下:

```c++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;

const int N = 1e5+10,INF = 0x3f3f3f3f;
int T,f[N][2],w[N];

int main(){
  cin>>T;
  
  while(T--){
    int n;
    cin>>n;
    
    for(int i = 1;i<=n;++i) scanf("%d",&w[i]);
    
    f[0][1] = -INF,f[0][0] = 0;
    for(int i = 1;i<=n;++i){
      f[i][0] = max(f[i-1][0],f[i-1][1]);
      f[i][1] = f[i-1][0]+w[i];
    }
    
    cout<<max(f[n][0],f[n][1])<<endl;
  }
  
  
  return 0;
}
```
<span style = "color:red">建议(tdk)</span>    

大道阿福这道题属于状态机模型的经典例题，里面只涉及到了两个状态的转移，相对好理解，并且我们可以知道有限状态自动机任意长度的路线都等价于某一方案，反之亦然！

