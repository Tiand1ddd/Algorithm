---
title: 数字三角形
categories:  
  - 动态规划
  - 数字三角形模型
tags:
  - dp
  - 线性dp
---

给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。

```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```

#### 输入格式

第一行包含整数 n𝑛，表示数字三角形的层数。

接下来 n行，每行包含若干整数，其中第 i𝑖 行表示数字三角形第 i𝑖 层包含的整数。

#### 输出格式

输出一个整数，表示最大的路径数字和。

#### 数据范围

1≤n≤5001

10000≤三角形中的整数≤10000

#### 输入样例：

```
5
7
3 8
8 1 0 
2 7 4 4
4 5 2 6 5
```

#### 输出样例：

```
30
```

#### 解题思路

<span style = "color: red;">状态表示</span>	如果我们从三角形顶部向下转移状态不方便处理循环迭代操作，所以可以定义`f[i][j]`为从底部到(i,j)的数字和。   

<span style = "color: red;">状态转移</span>	因为是由底部向上,所以路径中的任一点(i,j)由(i+1,j)或(i+1,j+1)走来,可以通过max来求`f[i][j]`的最大值。转移方程为`f[i][j] = max(f[i+1][j],f[i+1][j+1])`    

c++
```c++
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 510;
int f[N][N],w[N][N],n;

int main(){
  cin>>n;
  //在处理输入的过程中，我们可以直接定义一个二维数组不必处理每一行前面的空格,不影响状态转移;
  for(int i = 1;i<=n;++i){
    for(int j = 1;j<=i;++j){
      cin>>w[i][j];
    }
  }
  //在转移前要将f的最底层初始化,也可以不初始化,但是状态转移部分也就是下一个双重for循环i要从n开始,也就是最底层开始计算:
  /* for(int i = n;i;--i){
    for(int j = 1;j<=i;++j){
      f[i][j] = max(f[i+1][j],f[i+1][j+1])+w[i][j];
    }
  }*/
  for(int i = 1;i<=n;++i) f[n][i] = w[n][i];
  //注意此处的遍历是从底部开始的,所以i从n-1开始;
  for(int i = n-1;i;--i){
    for(int j = 1;j<=i;++j){
      f[i][j] = max(f[i+1][j],f[i+1][j+1])+w[i][j];
    }
  }
  
  cout<<f[1][1]<<endl;
  
  return 0;
}
```

<span style = "color: red;">建议(tdk)</span>      

dp(dynamic programming)问题如果第一次见我们往往无从下手的,所以不要过度纠结自己为什么想不出来,而是牢牢地记住处理这一类型问题的思路,比如关于网格一类型的基本状态表示为f(i,j),数字三角形就是一个基础的关于网格当中路径问题的模型,接下来我们将会陆续归纳这一类型问题。