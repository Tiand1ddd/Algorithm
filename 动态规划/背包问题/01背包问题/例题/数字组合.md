给定 N个正整数 $A_1$,$A_2$,…,$A_N$，从中选出若干个数，每个数只能取一次，使它们的和为 M，求有多少种选择方案。

#### 输入格式

第一行包含两个整数 N 和 M。

第二行包含 N 个整数，表示 $A_1$,$A_2$,…,$A_N$。

#### 输出格式

包含一个整数，表示可选方案数。

#### 数据范围

1≤N≤100,    

1≤M≤10000,    

1≤ $A_i$≤1000,    

答案保证在 int 范围内。

#### 输入样例：

```
4 4
1 1 2 2
```

#### 输出样例：

```
3
```

#### 解题思路

该题属于典型的01背包问题求方案数，重点在于理解方案数是如何通过状态方程进行转移。如果将这道题类比于01背包问题中的体积，价值，有如下类比:

$A_i$ ---> 物品为i的体积和价值      

M ---> 总的背包空间和要达成的总价值

根据01背包问题求最大价值我们可以定义:     

状态表示：`f[i]`表示恰好凑成整数i的集合，该集合表示的是方案数

状态转移：`f[i] = f[i]+f[i-v](i>=v)`从集合角度推导，可以参考如下图      

![](https://cdn.jsdelivr.net/gh/Tiand1ddd/tuchuang@main/img/202409041800883.jpg)

一般求解方案问题我们都需要定义初始值，这道题中我们可以定义`f[0] = 1`(这里使用了优化数组，不使用则是`f[0][0] = 1`)。代码如下：      

```C++
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N = 10010;
int f[N];

int main(){
  int n,m;
  cin>>n>>m;
  
  f[0] = 1;
  for(int i = 0;i<n;++i){
    int v;
    cin>>v;
    //此处通过直接处理v，可以不额外开通一个数组存储v，简化代码;
    for(int j = m;j>=v;--j){
      f[j] += f[j-v];
    }
  }
  
  cout<<f[m]<<endl;
  return 0;
}
```

以上就是基本的解题思路，那为什么要定义`f[0] = 1`以及这个1是如何一步一步转移到`f[i]`的呢？以至于最后`f[i]`就是最终的方案数？      

通过观察代码中的两个for循环，我们可以知道当输入了一个v(也就是整数$A_i$),`f[v]`是一定会从`f[0]`转移过来，那就是说，凑成v的方案数目前有一种。     

同样的，再输入一个$v_1$($v_1$>v)，可以肯定的一点是f[$ v_1 $]=1，再输入$v_2$($v_2+v == v_1$)，同样的$f[v_2] = 1$,但是f[$v_1$]的值不会发生变化吗？         

通过代码中的第二个for循环我们可以将`f[v]`的值转移到f[$v_1$]上，因为$v_2  +  v ==  v_1$，即$f[v_1] += f[v]$。      

也就是说现在凑成$v_1$的方案数有两种，一种是直接选择$v_1$，另一种则是选择$v$和$v_2$共同凑成$v_1$，以此类推下去，每输入一个$v_i$，内部都会遍历循环m次，将能凑成的每个整数进行转移，当然，转移的前提是$j>=v$。        

#### 时间复杂度
该题代码中使用了两个for循环，所以时间复杂度为$O(n^2)$。

#### 学习建议 
对于求解方案数的题目一定要记得定义初始值。简而言之，该题中的$f[i]$就是表示能凑成整数i的所有方案数，如果新加入一个v，则会将所有`f[i-v]`的方案加到`f[i]`上。